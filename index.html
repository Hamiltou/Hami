<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø± - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø©</title>
    <style>
        :root {
            --primary-color: #2196f3;
            --error-color: #f44336;
            --warning-color: #ff9800;
            --success-color: #4caf50;
        }

        /* Ø£Ù†Ù…Ø§Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„ */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .channel-card {
            border: 1px solid #eee;
            padding: 1rem;
            margin: 0.5rem;
            border-radius: 8px;
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .channel-card:hover {
            transform: translateY(-2px);
        }

        .video-player {
            width: 100%;
            max-width: 800px;
            margin: 1rem auto;
            border-radius: 8px;
            background: #000;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .online { background: var(--success-color); color: white; }
        .offline { background: var(--error-color); color: white; }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus"></div>
    <div class="loading-overlay" id="loading">
        <div class="loading-spinner"></div>
    </div>

    <div class="container">
        <h1>ğŸ¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©</h1>
        
        <div class="create-channel">
            <input type="text" id="channelName" placeholder="Ø§Ø³Ù… Ø§Ù„Ù‚Ù†Ø§Ø©" aria-label="Ø§Ø³Ù… Ø§Ù„Ù‚Ù†Ø§Ø©">
            <input type="number" id="maxVideos" min="1" value="5" aria-label="Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª">
            <button onclick="app.createChannel()">â• Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ù†Ø§Ø©</button>
        </div>

        <div id="channelsList" class="channels-grid"></div>

        <div id="playerSection" style="display:none;">
            <video id="mainVideo" class="video-player" controls playsinline></video>
            <button onclick="app.stopPlayback()">â¹ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ´ØºÙŠÙ„</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { 
            getFirestore, collection, onSnapshot,
            addDoc, updateDoc, doc, deleteDoc, 
            serverTimestamp, arrayUnion, increment,
            enableMultiTabIndexedDbPersistence, writeBatch,
            query, orderBy, limit
        } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
        import { 
            getStorage, ref, uploadBytesResumable, 
            getDownloadURL, deleteObject, listAll 
        } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-storage.js";

        class VideoApp {
            constructor() {
                this.firebaseConfig = {
                    apiKey: "AIzaSyB3...",
                    authDomain: "your-project.firebaseapp.com",
                    projectId: "your-project",
                    storageBucket: "your-project.appspot.com",
                    messagingSenderId: "123456789",
                    appId: "1:123456789:web:abcdef1234567890"
                };

                this.config = {
                    maxFileSize: 100 * 1024 * 1024, // 100MB
                    pageLimit: 10,
                    cacheTTL: 300000 // 5 Ø¯Ù‚Ø§Ø¦Ù‚
                };

                this.state = {
                    channels: new Map(),
                    currentPlaylist: [],
                    currentVideoIndex: 0,
                    unsubscribe: null,
                    isOnline: navigator.onLine
                };

                this.init();
            }

            async init() {
                try {
                    this.initializeFirebase();
                    this.setupConnectionMonitoring();
                    await this.enableOfflineSupport();
                    this.cacheElements();
                    this.restoreCachedData();
                    this.setupIntersectionObserver();
                    await this.setupRealtimeUpdates();
                    this.registerServiceWorker();
                } catch (error) {
                    this.handleError('Initialization Error', error);
                }
            }

            initializeFirebase() {
                this.app = initializeApp(this.firebaseConfig);
                this.db = getFirestore(this.app);
                this.storage = getStorage(this.app);
            }

            setupConnectionMonitoring() {
                window.addEventListener('online', () => this.updateConnectionStatus(true));
                window.addEventListener('offline', () => this.updateConnectionStatus(false));
                this.updateConnectionStatus(navigator.onLine);
            }

            updateConnectionStatus(online) {
                this.state.isOnline = online;
                const statusElement = document.getElementById('connectionStatus');
                statusElement.textContent = online ? 'Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª' : 'ØºÙŠØ± Ù…ØªØµÙ„';
                statusElement.className = `connection-status ${online ? 'online' : 'offline'}`;
            }

            async enableOfflineSupport() {
                try {
                    await enableMultiTabIndexedDbPersistence(this.db);
                    console.log('Offline support enabled');
                } catch (error) {
                    console.warn('Offline persistence error:', error);
                }
            }

            cacheElements() {
                this.elements = {
                    channelsList: document.getElementById('channelsList'),
                    mainVideo: document.getElementById('mainVideo'),
                    playerSection: document.getElementById('playerSection'),
                    channelName: document.getElementById('channelName'),
                    maxVideos: document.getElementById('maxVideos')
                };
            }

            setupIntersectionObserver() {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            this.preloadChannelData(entry.target.dataset.channelId);
                        }
                    });
                }, { rootMargin: '200px' });

                this.observer = observer;
            }

            async preloadChannelData(channelId) {
                const channel = this.state.channels.get(channelId);
                if (!channel || channel.videoUrls.length === 0) return;

                channel.videoUrls.forEach(url => {
                    const video = new Video();
                    video.src = url;
                    video.preload = 'metadata';
                });
            }

            restoreCachedData() {
                const cachedData = localStorage.getItem('channelsCache');
                if (cachedData) {
                    try {
                        const channels = JSON.parse(cachedData);
                        channels.forEach(channel => {
                            this.state.channels.set(channel.id, channel);
                            this.renderChannel(channel, true);
                        });
                    } catch (error) {
                        console.error('Cache restoration error:', error);
                    }
                }
            }

            async setupRealtimeUpdates() {
                const channelsQuery = query(
                    collection(this.db, 'channels'),
                    orderBy('createdAt', 'desc'),
                    limit(this.config.pageLimit)
                );

                this.state.unsubscribe = onSnapshot(channelsQuery, 
                    (snapshot) => this.handleSnapshot(snapshot),
                    (error) => this.handleError('Realtime Update Error', error)
                );
            }

            handleSnapshot = (snapshot) => {
                const changes = snapshot.docChanges();
                const batch = writeBatch(this.db);

                changes.forEach(change => {
                    const channel = this.processChange(change);
                    if (!channel) return;

                    switch (change.type) {
                        case 'added':
                        case 'modified':
                            this.updateChannelState(channel);
                            this.scheduleRender(channel);
                            break;
                        case 'removed':
                            this.removeChannel(channel.id);
                            break;
                    }
                });

                this.updateLocalCache();
                this.debouncedRender();
            }

            processChange(change) {
                const data = change.doc.data();
                return {
                    id: change.doc.id,
                    name: data.name,
                    maxVideos: data.maxVideos,
                    videoUrls: data.videoUrls || [],
                    createdAt: data.createdAt?.toDate()
                };
            }

            updateChannelState(channel) {
                this.state.channels.set(channel.id, channel);
            }

            scheduleRender(channel) {
                if (!this.renderQueue) this.renderQueue = new Map();
                this.renderQueue.set(channel.id, channel);
            }

            debouncedRender = () => {
                if (this.renderTimer) clearTimeout(this.renderTimer);
                this.renderTimer = setTimeout(() => {
                    this.renderQueue.forEach(channel => 
                        this.renderChannel(channel)
                    );
                    this.renderQueue.clear();
                }, 300);
            }

            renderChannel(channel, fromCache = false) {
                let element = document.querySelector(`[data-channel-id="${channel.id}"]`);
                
                if (!element) {
                    element = document.createElement('div');
                    element.className = 'channel-card';
                    element.dataset.channelId = channel.id;
                    this.elements.channelsList.prepend(element);
                    this.observer.observe(element);
                }

                element.innerHTML = this.generateChannelHTML(channel);
                this.attachChannelEvents(element, channel.id);
            }

            generateChannelHTML(channel) {
                return `
                    <h3>${this.sanitizeHTML(channel.name)}</h3>
                    <p>ğŸ¬ ${channel.videoUrls.length}/${channel.maxVideos}</p>
                    <div class="channel-actions">
                        <button class="play-btn" ${channel.videoUrls.length ? '' : 'disabled'}>
                            ${channel.videoUrls.length ? 'â–¶ï¸ ØªØ´ØºÙŠÙ„' : 'â›” ØºÙŠØ± Ù…ØªØ§Ø­'}
                        </button>
                        <button class="upload-btn" 
                            ${channel.videoUrls.length >= channel.maxVideos ? 'disabled' : ''}>
                            ğŸ“¤ Ø±ÙØ¹ ÙÙŠØ¯ÙŠÙˆ
                        </button>
                        <button class="delete-btn">ğŸ—‘ï¸ Ø­Ø°Ù</button>
                    </div>
                    ${!this.state.isOnline ? '<div class="offline-badge">âš¡ Ù…Ø®Ø²Ù† Ù…Ø­Ù„ÙŠÙ‹Ø§</div>' : ''}
                `;
            }

            attachChannelEvents(element, channelId) {
                element.querySelector('.play-btn').addEventListener('click', 
                    () => this.playChannel(channelId));
                element.querySelector('.upload-btn').addEventListener('click', 
                    () => this.uploadVideo(channelId));
                element.querySelector('.delete-btn').addEventListener('click', 
                    () => this.deleteChannel(channelId));
            }

            async createChannel() {
                const name = this.elements.channelName.value.trim();
                const maxVideos = parseInt(this.elements.maxVideos.value);

                if (!this.validateChannelInput(name, maxVideos)) return;

                try {
                    this.toggleLoading(true);
                    const newChannel = {
                        name,
                        maxVideos,
                        videoUrls: [],
                        createdAt: serverTimestamp()
                    };

                    await addDoc(collection(this.db, 'channels'), newChannel);
                    this.clearForm();
                    this.showToast('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
                } catch (error) {
                    this.handleError('Channel Creation', error);
                } finally {
                    this.toggleLoading(false);
                }
            }

            validateChannelInput(name, maxVideos) {
                if (!name || isNaN(maxVideos) || maxVideos < 1) {
                    this.showToast('âŒ Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©', 'error');
                    return false;
                }
                return true;
            }

            // ... (Ø¨Ù‚ÙŠØ© Ø§Ù„Ø¯ÙˆØ§Ù„ Ù…Ø¹ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…Ù…Ø§Ø«Ù„Ø©)

            registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('/service-worker.js')
                        .then(() => console.log('Service Worker registered'))
                        .catch(err => console.error('SW registration failed:', err));
                }
            }

            toggleLoading(show) {
                document.getElementById('loading').style.display = show ? 'flex' : 'none';
            }

            sanitizeHTML(str) {
                return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }

            showToast(message, type = 'info') {
                // ... (ØªÙ†ÙÙŠØ° toast Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡)
            }

            handleError(context, error) {
                // ... (Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø­Ø³Ù†Ø©)
            }
        }

        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
        const app = new VideoApp();
        window.app = app;

        // ØªØ³Ø¬ÙŠÙ„ Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('SW registered:', registration);
                    })
                    .catch(error => {
                        console.log('SW registration failed:', error);
                    });
            });
        }
        const CACHE_NAME = 'video-cache-v1';
const ASSETS = [
  '/',
  '/styles.css',
  '/app.js',
  '/assets/fallback-image.jpg'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(ASSETS))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        return response || fetch(event.request)
          .then(res => {
            if(event.request.url.includes('/videos/')) {
              const clone = res.clone();
              caches.open(CACHE_NAME)
                .then(cache => cache.put(event.request, clone));
            }
            return res;
          });
      })
      .catch(() => {
        if(event.request.destination === 'video') {
          return caches.match('/assets/fallback-video.mp4');
        }
        return caches.match('/');
      })
  );
});
    </script>
</body>
</html>
